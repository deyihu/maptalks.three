<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Customize your own components </title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.6/build/dat.gui.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/maptalks/dist/maptalks.css">
    <script type="text/javascript" src="./js/maptalks.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/three@0.104.0/build/three.min.js"></script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/three-text2d@0.5.3/dist/three-text2d.min.js"></script>

    <script type="text/javascript" src="../dist/maptalks.three.js"></script>
    <script type="text/javascript" src="./data/nystations.js"></script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/three@0.104.0/examples/js/libs/stats.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/rbush@3.0.1/rbush.min.js"></script>
    <script type="text/javascript"
        src="http://58.211.183.162:8941/yymap-examples/dist/assets/data/chinacitys.js"></script>

    <style>
        html,
        body {
            margin: 0px;
            height: 100%;
            width: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
            background-color: #000;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>

        var map = new maptalks.Map("map", {
            center: [120, 31],
            zoom: 5,

            centerCross: true,
            doubleClickZoom: false,
            // baseLayer: new maptalks.TileLayer('tile', {
            //     urlTemplate: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
            //     subdomains: ['a', 'b', 'c', 'd'],
            //     attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
            // })
        });

        map.on('click', function (e) {
            console.log(e.coordinate.toArray());
        });

        maptalks.ThreeLayer.prototype.collides = function () {
            this.rbush.clear();
            for (let i = 0, len = this.texts.length; i < len; i++) {
                const text = this.texts[i];
                const textRect = text.getTextRect();
                if (this.rbush.collides(textRect)) {
                    text.hide();
                } else {
                    text.show();
                    this.rbush.insert(textRect);
                }
            }
        }

        maptalks.ThreeLayer.prototype.texts = [];
        maptalks.ThreeLayer.prototype.rbush = new RBush();


        var threeLayer = new maptalks.ThreeLayer('t', {
            forceRenderOnMoving: true,
            forceRenderOnRotating: true,
            // animation: true
        });


        threeLayer.prepareToDraw = function (gl, scene, camera) {
            stats = new Stats();
            stats.domElement.style.zIndex = 100;
            document.getElementById('map').appendChild(stats.domElement);

            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, -10, 10).normalize();
            scene.add(light);
            addSprites();



        };
        threeLayer.addTo(map);

        map.on('zooming zoomend moveend animateend', () => {
            threeLayer.collides();
        });




        var textSprites = [];

        function addSprites() {
            const provinceMarkers = []; //省
            const cityMarkers = []; //地市
            const districtMarkers = []; //区域

            const children = chinacitys.children;

            children.forEach(province => {
                const name = province.name;
                provinceMarkers.push({
                    name,
                    coordinates: province.center
                });

                if (!province.children) cityMarkers.push({
                    name,
                    coordinates: province.center
                });

                (province.children || []).forEach(city => {
                    const name = city.name;
                    cityMarkers.push({
                        name,
                        coordinates: city.center
                    });
                });
            });

            districts.forEach(element => {
                const name = element.name;
                districtMarkers.push({
                    name,
                    coordinates: element.center
                });
            });
            provinceMarkers.forEach(element => {
                textSprites.push(new TextSprite(element.coordinates, { text: element.name, color: 'red', fontSize: 25, weight: 2, interactive: false }, threeLayer));
            });
            cityMarkers.forEach(element => {
                textSprites.push(new TextSprite(element.coordinates, { text: element.name, color: 'yellow', weight: 1, interactive: false }, threeLayer));
            });
            districtMarkers.forEach(element => {
                textSprites.push(new TextSprite(element.coordinates, { text: element.name, fontSize: 15, interactive: false }, threeLayer));
            });

            textSprites.sort(function (text1, text2) {
                text2.getOptions().weight - text1.getOptions().width;
            });
            threeLayer.texts = textSprites;
            textSprites.forEach(textSprite => {
                textSprite.on('add', () => {
                    const textRect = textSprite.getTextRect();
                    if (threeLayer.rbush.collides(textRect)) {
                        textSprite.hide();
                    } else {
                        textSprite.show();
                        threeLayer.rbush.insert(textRect);
                    }
                })
            });
            threeLayer.addMesh(textSprites);
            threeLayer.collides();
            animation();
        }

        function animation() {
            // layer animation support Skipping frames
            threeLayer._needsUpdate = !threeLayer._needsUpdate;
            if (threeLayer._needsUpdate) {
                threeLayer._renderer.clearCanvas();
                threeLayer.renderScene();
                // if (!map.isInteracting()) {
                //     threeLayer.collides();
                // }
                threeLayer.collides();
            }
            stats.update();
            requestAnimationFrame(animation);
        }


        //default values
        var OPTIONS1 = {
            fontSize: 20,
            altitude: 0,
            color: '#fff',
            text: 'hello',
            weight: 0
        };

        /**
         * custom component
         * We can think of it as a point.
         * */

        class TextSprite extends maptalks.BaseObject {
            constructor(coordinate, options, layer) {
                options = maptalks.Util.extend({}, OPTIONS1, options, { layer, coordinate });
                super();
                //Initialize internal configuration
                // https://github.com/maptalks/maptalks.three/blob/1e45f5238f500225ada1deb09b8bab18c1b52cf2/src/BaseObject.js#L135
                this._initOptions(options);
                const { altitude, fontSize, color, text } = options;


                //Initialize internal object3d
                // https://github.com/maptalks/maptalks.three/blob/1e45f5238f500225ada1deb09b8bab18c1b52cf2/src/BaseObject.js#L140
                this._createGroup();
                const textsprite = new THREE_Text2D.SpriteText2D(text, { align: THREE_Text2D.textAlign.center, font: `${fontSize * 2}px Arial`, fillStyle: color, antialias: false });
                textsprite.children[0].material.sizeAttenuation = false;
                const scale = 0.01 / 10 / 3;
                textsprite.scale.set(scale, scale, scale);
                this.getObject3d().add(textsprite);

                //set object3d position
                const z = layer.distanceToVector3(altitude, altitude).x;
                const position = layer.coordinateToVector3(coordinate, z);
                this.getObject3d().position.copy(position);
                this.textRect = {
                    width: this.calTextWidth(text, fontSize),
                    height: fontSize
                }

                this._vector = new THREE.Vector3();
                this._mapView = null;
                this._pixel = {
                    x: 0,
                    y: 0
                };
                // this._animation();
            }

            getTextRect() {
                this.getPixel();
                const { x, y } = this._pixel;
                const { width, height } = this.textRect;
                return {
                    minX: x - width / 2,
                    minY: y - height / 2,
                    maxX: x + width / 2,
                    maxY: y + height / 2
                }
            }

            calTextWidth(text, fontSize) {
                const chinese = text.match(/[\u4e00-\u9fa5]/g) || '';
                const chineseLen = chinese.length;
                const width = chineseLen * fontSize + (text.length - chineseLen) * 0.5 * fontSize;
                return width;
            }

            getPixel() {
                const size = this.getMap().getSize();
                const camera = this.getLayer().getCamera();
                const position = this.getObject3d().position;
                this._vector.x = position.x;
                this._vector.y = position.y;
                this._vector.z = position.z;
                this._pixel = simplepath.vector2Pixel(this._vector, size, camera);
            }


            // _animation() {
            //     const { center, zoom, pitch, bearing } = this.getMap().getView();
            //     center.push(zoom, pitch, bearing);
            //     const mapView = center.join(',').toString();
            //     // console.log(mapView);
            //     if (mapView !== this._mapView) {
            //         const size = this.getMap().getSize();
            //         const camera = this.getLayer().getCamera();
            //         const position = this.getObject3d().position;
            //         this._vector.x = position.x;
            //         this._vector.y = position.y;
            //         this._vector.z = position.z;
            //         this._pixel = simplepath.vector2Pixel(this._vector, size, camera);
            //         this._mapView = mapView;
            //     }
            // }

            identify(coordinate) {
                const { minX, minY, maxX, maxY } = this.getTextRect();
                const pixel = this.getMap().coordToContainerPoint(coordinate);
                if (pixel.x >= minX && pixel.x <= maxX && pixel.y >= minY && pixel.y <= maxY) {
                    return true;
                }
                return false;
            }


        }


        var simplepath = {

            positionsConvert: function (worldPoints, altitude = 0, layer) {
                const vectors = [];
                for (let i = 0, len = worldPoints.length; i < len; i += 3) {
                    let x = worldPoints[i], y = worldPoints[i + 1], z = worldPoints[i + 2];
                    if (altitude > 0) {
                        z += layer.distanceToVector3(altitude, altitude).x;
                    }
                    vectors.push(new THREE.Vector3(x, y, z));
                }
                return vectors;
            },

            vectors2Pixel: function (worldPoints, size, camera, altitude = 0, layer) {
                if (!(worldPoints[0] instanceof THREE.Vector3)) {
                    worldPoints = simplepath.positionsConvert(worldPoints, altitude, layer);
                }
                const pixels = worldPoints.map(worldPoint => {
                    return simplepath.vector2Pixel(worldPoint, size, camera);
                })
                return pixels;

            },

            vector2Pixel: function (world_vector, size, camera) {
                const vector = world_vector.project(camera);
                const halfWidth = size.width / 2;
                const halfHeight = size.height / 2;
                const result = {
                    x: Math.round(vector.x * halfWidth + halfWidth),
                    y: Math.round(-vector.y * halfHeight + halfHeight)
                };
                return result;
            },

        };





    </script>
</body>

</html>
