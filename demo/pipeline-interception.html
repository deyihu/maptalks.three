<!DOCTYPE html>
<html>

<head>
    <title>terrain test</title>
    <script type="text/javascript" src="https://unpkg.com/dat.gui@0.7.6/build/dat.gui.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://unpkg.com/maptalks/dist/maptalks.css">
    <script type="text/javascript" src="https://unpkg.com/maptalks/dist/maptalks.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@maptalks/gl/dist/maptalksgl.js"></script>
    <script type="text/javascript" src="./js/accesstoken.js"></script>
    <script type="text/javascript" src="https://unpkg.com/three@0.138.0/build/three.min.js"></script>
    <!-- <script type="text/javascript" src="https://unpkg.com/lz-string@1.4.4/libs/lz-string.min.js"></script> -->
    <script type="text/javascript" src="https://unpkg.com/maptalks.three@latest/dist/maptalks.three.js"></script>
    <!-- <script type="text/javascript" src="./https://unpkg.com/maptalks.three@latest/dist/maptalks.three.js"></script> -->
    <script type="text/javascript" src="https://unpkg.com/three@0.109.0/examples/js/libs/stats.min.js"></script>
    <script type="text/javascript" src="./js/tilebelt.js"></script>
    <script type="text/javascript" src="https://unpkg.com/turf@7.0.0-alpha.1/dist/turf.js"></script>
    <script type="text/javascript" src="https://unpkg.com/echarts@5.4.0/dist/echarts.min.js"></script>
    <style>
        html,
        body {
            margin: 0px;
            height: 100%;
            width: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
            /* background-color: #000; */
        }

        .charts {
            position: absolute;
            z-index: 1;
            right: 10px;
            bottom: 130px;
            width: 600px;
            height: 300px;
            background-color: black;

        }
    </style>
</head>

<body>
    <div class="charts" id="charts"></div>
    <div id="map"></div>
    <script>
        const chart = echarts.init(document.querySelector('#charts'));

        function updateChart(result) {
            const option = {
                tooltip: {
                    trigger: 'item',
                    // formatter: function (params) {
                    //     console.log(params);
                    // }
                    // show: true,
                    // formatter: '{b0}: {c0}<br />{b1}: {c1}'
                },
                xAxis: {
                    type: 'category',
                    data: result.map(d => {
                        return d.tube.getOptions().lineString.getProperties().name
                    }),
                    splitLine: {
                        show: true
                    }
                },
                yAxis: {
                    type: 'value',
                    name: '海拔',
                    splitLine: {
                        show: false
                    }
                },
                series: [
                    {
                        name: 'tube',
                        symbolSize: 40,
                        lineStyle: {
                            width: 0
                        },
                        tooltip: {
                            trigger: 'item',
                            formatter: function (params) {
                                const data = params.data;
                                return `${data.name}<br>半径:${data.radius} 米<br>海拔:${data.altitude}米`
                            }
                            // show: true,
                            // formatter: '{b0}: {c0}<br />{b1}: {c1}'
                        },
                        data: result.map(d => {
                            return {
                                value: d.altitude,
                                altitude: d.altitude,
                                radius: d.tube.getOptions().radius,
                                name: d.tube.getOptions().lineString.getProperties().name
                            }
                        }),
                        type: 'line'
                    }
                ]
            };

            chart.setOption(option);
        }


        var baseLayer = new maptalks.TileLayer('tile', {
            // urlTemplate: 'https://mt2.google.cn/maps/vt?lyrs=s&hl=zh-CN&gl=CN&x={x}&y={y}&z={z}',
            urlTemplate: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            subdomains: ['a', 'b', 'c', 'd'],
            debug: true,
            debugOutline: 'red'
            // attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
        });


        var map = new maptalks.Map("map", {
            "center": [106.2020618728119, 38.904062897947455], "zoom": 14, "pitch": 58.40000000000002, "bearing": 0,
            // center: [0, 0],
            // bearing: 180,

            centerCross: true,
            doubleClickZoom: false,
            baseLayer: baseLayer,
            zoomControl: true,
            // heightFactor: 2.4
        });
        // baseLayer.hide();

        const textureLoader = new THREE.TextureLoader();
        const terrains = [];
        const bboxs = [];
        let clipBuffer = 100;
        let tubes, tubeColor = '#fff';
        let clip = false;
        let clipPlanes = [];
        let clipPlane;
        const tubeRadius = 100, tubeAltitude = 600;

        var params = {
            clip: false,
            clipBuffer,
            clipPlane: false,
            clipPlaneColor: '#fff',
            baseLayer: baseLayer.isVisible(),
            terrains: true,
            tubes: true,
            tubeColor,
            // add: true,
            // color: 0x00ffff,
            // show: true,
            // opacity: 1,
            altitude: 0
        };

        // the ThreeLayer to draw buildings
        var threeLayer = new maptalks.ThreeLayer('t', {
            forceRenderOnMoving: true,
            forceRenderOnRotating: true,
            identifyCountOnEvent: 1
            // animation: true
        });

        var stats;
        threeLayer.prepareToDraw = function (gl, scene, camera) {
            threeLayer.getThreeRenderer().localClippingEnabled = true;
            stats = new Stats();
            stats.domElement.style.zIndex = 100;
            document.getElementById('map').appendChild(stats.domElement);

            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, -10, 10).normalize();
            scene.add(light);
            addTerrain();
            animation();
            initGui();
        }


        function addTerrain() {
            const TILESIZE = 256;
            const minx = 26046, maxx = 26053, miny = 12532, maxy = 12537;
            const tiles = [];
            for (let x = minx; x <= maxx; x++) {
                for (let y = miny; y <= maxy; y++) {
                    tiles.push([x, y, 15]);
                }
            }
            tiles.forEach(tile => {
                const [x, y, z] = tile;
                if (x >= 26050 && x <= 26051 && y >= 12534 && y <= 12535) {
                    return;
                }
                const bbox = tilebelt.tileToBBOX(tile);
                const texture = `https://api.mapbox.com/v4/mapbox.satellite/${z}/${x}/${y}.png?access_token=${accesstoken}`;
                const image = `https://a.tiles.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}.pngraw?access_token=${accesstoken}`;
                const terrain = threeLayer.toTerrain(bbox, { texture, imageWidth: TILESIZE, imageHeight: TILESIZE, image }, new THREE.MeshBasicMaterial());
                threeLayer.addMesh(terrain);
                terrains.push(terrain);
                bboxs.push(bbox);
            });
            addHelper();
            addTube();

        }

        function addHelper() {
            const bbox = calBBox(bboxs);
            const extent = new maptalks.Extent(bbox);
            const v = threeLayer.coordinateToVector3(extent.getCenter());
            const axesHelper1 = new THREE.AxesHelper(200);
            axesHelper1.position.copy(v);
            // threeLayer.addMesh(axesHelper1);
        }


        function calBBox() {
            let minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
            bboxs.forEach(bbox => {
                minx = Math.min(minx, bbox[0], bbox[2]);
                miny = Math.min(miny, bbox[1], bbox[3]);
                maxx = Math.max(maxx, bbox[2], bbox[0]);
                maxy = Math.max(maxy, bbox[3], bbox[1]);
            });
            return [minx, miny, maxx, maxy];
        }

        function addTube() {
            const material = new THREE.MeshLambertMaterial({ side: 2, color: tubeColor });
            var highlightmaterial = new THREE.MeshLambertMaterial({ side: 2, color: 'red', wireframe: true, transparent: true });
            fetch('./data/tubedata.geojson').then(res => res.json()).then(geojson => {
                const lines = maptalks.GeoJSON.toGeometry(geojson);
                tubes = lines.map(line => {
                    const coordinates = line.getCoordinates().forEach(c => {
                        c.z = 400 + Math.round(200 * (Math.random()));
                    })
                    const tube = new Tube(line, { radius: tubeRadius, radialSegments: 50 }, material, threeLayer);
                    tube.setToolTip(line.getProperties().name, {
                        showTimeout: 0,
                        eventsPropagation: true,
                        dx: 10
                    });
                    //event test
                    ['mouseout', 'mouseover'].forEach(function (eventType) {
                        tube.on(eventType, function (e) {
                            // console.log(e.type, e);
                            // console.log(this);
                            if (e.type === 'mouseout') {
                                this.setSymbol(material);
                            }
                            if (e.type === 'mouseover') {
                                highlightmaterial.clippingPlanes = params.clip ? clipPlanes : [];
                                this.setSymbol(highlightmaterial);
                            }
                        });
                    });
                    return tube;
                });
                threeLayer.addMesh(tubes);
                createClipPlanes();
            })
        }


        function createClipPlanes() {
            const bbox = calBBox(bboxs);
            const [minx, miny, maxx, maxy] = bbox;
            const clipBuffer = params.clipBuffer;
            const vymin = threeLayer.coordinateToVector3([(minx + maxx) / 2, miny]);
            const buffer = threeLayer.distanceToVector3(clipBuffer, clipBuffer).x;

            // const vymax = threeLayer.coordinateToVector3([(minx + maxx) / 2, maxy]);
            // console.log(vymax);

            // const extent = new maptalks.Extent(bbox);
            // const vc = threeLayer.coordinateToVector3(extent.getCenter());

            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -(Math.abs(vymin.y) + buffer));
            clipPlanes = [plane];
            // const plane1 = new THREE.Plane(new THREE.Vector3(0, -1, 0), (Math.abs(vymax.y) - buffer));
            // const helper = new THREE.PlaneHelper(plane, 233, 0xffff00);
            // helper.position.copy(vc);
            // threeLayer.addMesh(helper);

            function updateClipPlanePosition() {
                const v = threeLayer.coordinateToVector3([minx / 2 + maxx / 2, miny]);
                v.y += buffer;
                clipPlane.position.x = v.x;
                clipPlane.position.y = v.y;
            }
            if (!clipPlane) {
                const v1 = threeLayer.coordinateToVector3([minx, miny]), v2 = threeLayer.coordinateToVector3([maxx, miny]);
                const w = Math.abs(v1.x - v2.x);
                const h = 30;
                const geometry = new THREE.PlaneGeometry(w, h, 20, 10);
                geometry.rotateX(Math.PI / 2);
                const material = new THREE.MeshBasicMaterial({ wireframe: true });
                clipPlane = new THREE.Mesh(geometry, material);
                // textureLoader.load('./data/nitu.jpg', (texture) => {
                //     material.map = texture;
                // });
                updateClipPlanePosition();
                clipPlane.position.z = h / 2;
                clipPlane.visible = false;
            }
            updateClipPlanePosition();
            calCrossPoints();


        }

        function clipTubes() {
            const clip = params.clip;
            if (clip) {
                threeLayer.addMesh(clipPlane);
            } else {
                threeLayer.removeMesh(clipPlane)
            }
            const result = calCrossPoints();
            updateChart(result);
            tubes.concat(terrains).forEach(tube => {
                tube.getObject3d().material.clippingPlanes = clip ? clipPlanes : [];
                tube.getObject3d().material.clipIntersection = true;
                tube.getObject3d().material.needsUpdate = true;

            });
        }

        function calCrossPoints() {
            if (!params.clip) {
                return [];
            }
            const clipBuffer = params.clipBuffer;
            const bbox = calBBox(bboxs);
            const point = turf.point(bbox.slice(0, 2));
            const distance = clipBuffer / 1000;
            const bearing = 0;

            const destination = turf.destination(point, distance, bearing);
            const lat = destination.geometry.coordinates[1];

            const coordinates = [[bbox[0], lat], [bbox[2], lat]];
            const clipLine = turf.lineString(coordinates);
            const result = [];
            layer.clear();
            tubes.forEach(tube => {
                const lineString = tube.getOptions().lineString;
                const coordinates = lineString.getCoordinates().map(c => {
                    return c.toArray();
                });
                const line = turf.lineString(coordinates);
                const intersects = turf.lineIntersect(clipLine, line);
                const intersectPoint = intersects.features[0];
                if (intersectPoint) {
                    // const markers = maptalks.GeoJSON.toGeometry(intersects);
                    // layer.addGeometry(markers);
                    // layer.addGeometry(lineString);
                    const altitude = calCrossAltitude(intersects.features[0], coordinates);
                    result.push({
                        coordinates: intersectPoint.geometry.coordinates,
                        altitude,
                        tube
                    });
                }
            });
            return result;
        }

        function calCrossAltitude(intersectPoint, lineCoordinates) {
            let altitude = 0;
            if (!intersectPoint) {
                return altitude;
            }
            const [x, y] = intersectPoint.geometry.coordinates;
            const point = new maptalks.Coordinate(x, y);
            const POINT1 = new maptalks.Coordinate(0, 0), POINT2 = new maptalks.Coordinate(0, 0);
            for (let i = 0, len = lineCoordinates.length - 1; i < len; i++) {
                const [x1, y1, z1] = lineCoordinates[i], [x2, y2, z2] = lineCoordinates[i + 1];
                POINT1.x = x1;
                POINT1.y = y1;
                POINT2.x = x2;
                POINT2.y = y2;
                if (pointOnLine(point, POINT1, POINT2)) {
                    const dx = x2 - x1, dy = y2 - y1;
                    const [x, y] = intersectPoint.geometry.coordinates;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const offsetDx = x - x1, offsetDy = y - y1;
                    const offsetDistance = Math.sqrt(offsetDx * offsetDx + offsetDy * offsetDy);
                    const dHeight = z2 - z1;
                    altitude = z1 + dHeight * (offsetDistance / distance);
                    break;
                }
            }
            return altitude;
        }


        // 确定点是否在线段上
        function pointOnLine(point, startPoint, endPoint) {
            const x = point.x;
            const y = point.y;
            const x1 = startPoint.x;
            const y1 = startPoint.y;
            const x2 = endPoint.x;
            const y2 = endPoint.y;
            const dxc = x - x1;
            const dyc = y - y1;
            const dxl = x2 - x1;
            const dyl = y2 - y1;
            const cross = dxc * dyl - dyc * dxl;
            if (Math.abs(cross) > 0.1) {
                return;
            }
            if (Math.abs(dxl) >= Math.abs(dyl)) {
                if (dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1) {
                    return true;
                }
            } else if (dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1) {
                return true;
            }
        }

        const sceneConfig = {
            postProcess: {
                enable: true,
                antialias: { enable: true }
            }
        };
        const groupLayer = new maptalks.GroupGLLayer('group', [threeLayer], { sceneConfig });
        groupLayer.addTo(map);

        const layer = new maptalks.VectorLayer('layer').addTo(map);

        function animation() {
            // layer animation support Skipping frames
            threeLayer._needsUpdate = !threeLayer._needsUpdate;
            if (threeLayer._needsUpdate && !threeLayer.isRendering()) {
                threeLayer.redraw();
            }
            stats.update();
            requestAnimationFrame(animation);

        }


        function initGui() {
            var gui = new dat.GUI();
            gui.add(params, 'baseLayer').onChange(function () {
                baseLayer[params.baseLayer ? 'show' : 'hide']();
            });
            gui.add(params, 'clip').onChange(function () {
                clipTubes(params.clip);
            });
            gui.add(params, 'clipBuffer', 0, 2000).name('clipBuffer(Meter)').onChange(function () {
                createClipPlanes(params.clipBuffer);
                clipTubes(params.clip);
            });
            gui.add(params, 'clipPlane').onChange(function () {
                clipPlane.visible = params.clipPlane;
            });
            gui.addColor(params, 'clipPlaneColor').onChange(function () {
                if (clipPlane) {
                    clipPlane.material.color.setStyle(params.clipPlaneColor);
                }
            });

            gui.add(params, 'terrains').onChange(function () {
                if (params.terrains) {
                    threeLayer.addMesh(terrains);
                } else {
                    threeLayer.removeMesh(terrains);
                }
            });
            gui.add(params, 'tubes').onChange(function () {
                if (params.tubes) {
                    threeLayer.addMesh(tubes);
                } else {
                    threeLayer.removeMesh(tubes);
                }
            });
            gui.addColor(params, 'tubeColor').onChange(function () {
                tubes.forEach(function (tube) {
                    tube.getObject3d().material.color.setStyle(params.tubeColor);
                });
            });
        }


        //default values
        var OPTIONS = {
            radius: 5,
            altitude: 0,
            radialSegments: 10
        };

        class Tube extends maptalks.BaseObject {
            constructor(lineString, options, material, layer) {
                const center = lineString.getCenter();
                options = maptalks.Util.extend({}, OPTIONS, options, { layer, lineString, coordinates: center });
                super();
                //Initialize internal configuration
                // https://github.com/maptalks/maptalks.three/blob/1e45f5238f500225ada1deb09b8bab18c1b52cf2/src/BaseObject.js#L135
                this._initOptions(options);
                const { altitude, radius } = options;
                const centerPt = layer.coordinateToVector3(center);
                const pts = lineString.getCoordinates().map(c => {
                    const pt = layer.coordinateToVector3(c);
                    pt.sub(centerPt);
                    const altitude = c.z;
                    if (altitude) {
                        pt.z = layer.altitudeToVector3(altitude).x;
                    }
                    return pt;
                })
                const curve = new THREE.CatmullRomCurve3(pts);

                // const points = curve.getPoints(pts.length);
                //generate geometry
                const r = layer.distanceToVector3(radius, radius).x;
                const geometry = new THREE.TubeGeometry(curve, pts.length * 10, r, options.radialSegments, false);

                //Initialize internal object3d
                // https://github.com/maptalks/maptalks.three/blob/1e45f5238f500225ada1deb09b8bab18c1b52cf2/src/BaseObject.js#L140
                this._createMesh(geometry, material);

                //set object3d position
                const z = layer.altitudeToVector3(altitude, altitude).x;
                centerPt.z = z;
                this.getObject3d().position.copy(centerPt);
                // this.getObject3d().rotation.x = -Math.PI;
            }



        }


    </script>
</body>

</html>